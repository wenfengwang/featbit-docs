import { Callout } from 'nextra/components'

# アーキテクチャ - プロフェッショナル

<Callout type="info" >
このドキュメントはプロフェッショナル版向けです。標準版については[アーキテクチャ](architecture.md)を参照してください。標準版とプロフェッショナル版の違いについては、[Standard VS. Professional](standard-vs.-professional.md)をご覧ください。
</Callout>

## **概要**

FeatBitは、**スケーラブル**かつ**高速**なフィーチャー管理プラットフォームです。FeatBitのミッションは、すべてのチームがソフトウェアの提供、制御、実験、収益化を行えるようにすることです。

全体的なアーキテクチャは以下の通りです：

![](../tech-stack/assets/architecture-professional/001.png)

* **UI :** ユーザーに機能フラグ、セグメント、実験などを管理・公開するための視覚的なUIインターフェースを提供します。
* **APIサーバー :** UIおよび外部統合サービス（フラグトリガー、コード参照など）のデータ管理機能を提供します。
* **評価サーバー :** スケーラブルで高性能なフラグルール評価エンジンとデータ配信サーバーを提供します。
* **データアナリティクスサーバー :** データ分析エンジンを提供します。以下のサービスを保証します：
  * 実験を計算し、その結果をほぼリアルタイムで返します。
  * UI内のすべての分析に対するインサイトサービスを提供します。例えば、フィーチャーフラグレポートなどです。
* **SDK:** すべての主要な言語とフレームワーク向けのSDKを提供し、サービスやアプリケーションからFeatBitに迅速にアクセスできます。
* **Redis :** パフォーマンスを向上させるキャッシュ層。
* **Kafka :** 異なるサービス間で高スループットの非同期データ通信を保証するメッセージキュー。これにより、全体的なパフォーマンスが向上し、サービス間が分離されます。
* **MongoDB :** 主データベース。すべてのフィーチャーフラグ、セグメント、実験、およびエンドユーザーデータはMongoDBに保存されます。
* **ClickHouse :** 分析サービス用のデータベース。ここにはすべてのフィーチャー呼び出しとメトリック呼び出しのログが格納されます。

## スケーラブルかつ高性能

アーキテクチャを設計する際、最も重要かつ唯一の関心事は、それをスケーラブルにし、可能な限り最高のパフォーマンスを実現する方法でした。そのために、テックスタックを慎重に選択し、すべてのサービスをコンテナ化しました。これにより、クラスタとしてのデプロイが容易になり、**水平スケーリング**が非常に簡単になります。

データストレージとサービス間のデータフローに関しては、最高のパフォーマンスを得るために、MongoDBを主データストアとして、Redisをシステムキャッシュとして、Kafkaをメッセージキューとして、ClickHouseを分析およびA/B/nテストデータのデータストアとして導入しました。**マルチプレクシング**と**Pub & Subシステム**を使用してサービス間でメッセージを送受信し、平均反応時間はミリ秒単位です。

フィーチャーフラグの変更やその他の設定をSDKにプッシュするのはほぼリアルタイムです。UIからフラグが変更された場合、SDKへのデータプッシュには**100ミリ秒未満**かかります。長時間のポーリングの代わりに、WebSocketソリューションが採用されています。これにより、変更が発生した際にSDKへのプッシュが積極的に行われます。もちろん、これにはメモリが大量に消費される可能性がありますが、膨大な数の同時リクエストが発生した場合でも、シリアライズとデシリアライズのプロセス中に余分なメモリを消費しないように、データのシリアライズとデシリアライズの方法を慎重に選択しました。

## データフロー

システムが稼働している間、異なるサービス間でデータが流れます。主なデータフローは4つあります：

### データ同期（フィーチャーフラグ／セグメント）データフロー

フィーチャーフラグ／セグメントデータはMongoDBに保存され、FeatBitのすべての主要機能にとって最も重要なデータストアです。

クライアントまたはサーバーSDKと評価サーバーとの間に接続が確立された後、SDKは最新の変更のタイムスタンプを添付したデータ同期リクエストを評価サーバーに送信します。評価サーバーはそのタイムスタンプをチェックし、Redisから適切なフィーチャーフラグとセグメントを取得し、最終的な評価プロセス（クライアントSDKのみ）を経て、結果をSDKに返送します。応答には2つのタイプがあります：

* **full**: 応答にはすべてのフィーチャーフラグとセグメントが含まれます。
* **patch**: 応答には、タイムスタンプ以降に作成または更新された新しいフィーチャーフラグとセグメントのみが含まれます。

![](../tech-stack/assets/architecture-professional/002.png)

### フィーチャーフラグ／セグメント変更データフロー

ユーザーがUIからフィーチャーフラグまたはセグメントを変更すると、MongoDBにデータを保存するだけでなく、APIサーバーも変更をKafkaにプッシュします。評価サーバーはこれらの変更を読み取り、Redisを更新し、変更に関連するフィーチャーフラグを評価し、関連するフィーチャーフラグまたは評価結果をWebSocket接続を介してクライアント／サーバー側SDKに送信します。

![](../tech-stack/assets/architecture-professional/003.png)

### エンドユーザーデータフロー

エンドユーザーデータはMongoDBに保存され、フィーチャーフラグとセグメントのターゲティングに使用されます。

クライアントSDKがWebSocket接続を確立するか、別のユーザーに切り替えるか（identify APIを呼び出す）、またはクライアント／サーバーSDKがトラックメッセージを送信すると、評価サーバーはエンドユーザー情報をKafkaに送信し、APIサーバーはそのデータを読み取ってMongoDBに更新／挿入します。

![](../tech-stack/assets/architecture-professional/004.png)

### フィーチャーフラグとメトリックトラックデータフロー

フィーチャーフラグとメトリックトラックデータはClickHouseに保存され、A/B/nテスト（実験）とレポーティングに使用されます。

クライアント／サーバーSDKがフィーチャーフラグとメトリックトラックメッセージを評価サーバーに送信すると、評価サーバーはトラックメッセージをKafkaに転送し、データアナリティクスサーバーはKafkaからトラックメッセージを読み取ってClickHouseに保存します。

![](../tech-stack/assets/architecture-professional/005.png)

## **あなたがすべてのデータの唯一の所有者です**

全体的なアーキテクチャは、すべてのデータと通信がシステム内に留まるため、プライバシーを保護します。サードパーティのサービスにデータを送信することはありません。お客様がすべてのデータの唯一の所有者であり、私たちは[GDPR](https://gdpr-info.eu/)に完全に準拠していると自信を持って言えます。
