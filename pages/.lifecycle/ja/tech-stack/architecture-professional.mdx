import { Callout } from 'nextra/components'

# アーキテクチャ - プロフェッショナル

<Callout type="info">
このドキュメントはプロフェッショナルバージョン向けです。標準バージョンについては、[アーキテクチャ](architecture.md)を参照してください。標準とプロフェッショナルバージョンの違いについては、[標準 VS プロフェッショナル](standard-vs.-professional.md)をご確認ください。
</Callout>

## **概要**

FeatBitは、**スケーラブル**かつ**高速**なフィーチャーマネジメントプラットフォームです。FeatBitのミッションは、すべてのチームがソフトウェアを提供、管理、実験、および収益化できるようにすることです。

全体のアーキテクチャは次のとおりです：

![](../tech-stack/assets/architecture-professional/001.png)

* **UI：** ユーザーに対して、フィーチャーフラグ、セグメント、実験などを管理するためのビジュアルUIインターフェースを提供します。
* **APIサーバー：** UIおよび外部統合サービス（フラグトリガー、コードリファレンスなど）に対するデータ管理機能を提供します。
* **評価サーバー：** スケーラブルで高性能なフラグルール評価エンジンおよびデータ分配サーバーを提供します。
* **データ分析サーバー：** データ分析エンジンを提供します。以下のサービスを保証します。
  * 実験を計算し、リアルタイムに結果を返します。
  * フィーチャーフラグのレポートなど、UI内のすべての分析に対する洞察サービスを提供します。
* **SDK：** 主要な言語とフレームワーク用のSDKを提供し、サービスとアプリケーションからFeatBitにすばやくアクセスできます。
* **Redis：** パフォーマンスを向上させるためのキャッシュレイヤーです。
* **Kafka：** 異なるサービス間の高スループット非同期データ通信を保証するメッセージキューです。全体のパフォーマンスを向上させるだけでなく、サービスを分離します。
* **MongoDB：** メインデータベースです。すべてのフィーチャーフラグ、セグメント、実験、エンドユーザーデータはMongoDBに保存されます。
* **ClickHouse：** 分析サービス用のデータベースです。そこにはフィーチャーコールやメトリクスコールのすべてのログが含まれます。

## スケーラブルで高性能

アーキテクチャを設計する際、最も重要で唯一の関心事は、スケーラブルにすることと、可能な限り最高のパフォーマンスを得ることです。そのために、私たちは慎重にテックスタックを選び、すべてのサービスをコンテナ化しました。これにより、クラスターとして簡単にデプロイし、**水平方向にスケーリング**することができます。

データストレージとサービス間のデータフローに関しては、最高のパフォーマンスを得るために、メインデータストアとしてMongoDB、システムキャッシュとしてRedis、メッセージキューとしてKafka、分析およびA/B/nテストデータ用のデータストアとしてClickHouseを導入しました。私たちは**マルチプレクシング**と**パブ＆サブシステム**を使用して、サービス間でメッセージを送受信しています。平均反応時間はミリ秒単位です。

フラグの変更やその他の設定をSDKにプッシュすることは、リアルタイムに近いです。UIからフラグが変更された場合、データをSDKにプッシュするのに100ミリ秒未満かかります。ロングポーリングの代わりに、WebSocketソリューションが採用されています。これにより、変更が発生するとすぐにSDKに変更がプッシュされます。もちろん、これは無料ではありません。大量の同時リクエストが発生すると、膨大なメモリを消費する可能性があります。メモリモンスターにならないようにするために、データのシリアライズおよびデシリアライズのプロセス中に余分なメモリを消費しないように、注意深くデータのシリアライズおよびデシリアライズの方法を選択しました。

## データのフロー

システムが動作しているとき、データはさまざまなサービス間でフローします。主なデータフローには次の4つがあります。

### データ同期（フィーチャーフラグ/セグメント）のデータフロー

フィーチャーフラグ/セグメントデータはMongoDBに格納され、FeatBitの主要な機能のために使用されます。

クライアントまたはサーバーのSDKと評価サーバーの間に接続が確立された後、SDKは最新の変更のタイムスタンプとともにデータ同期リクエストを評価サーバーに送信します。評価サーバーはそのタイムスタンプを確認し、Redisから適格なフィーチャーフラグとセグメントを取得します。評価プロセス（クライアントSDKの場合のみ）の結果はSDKに送信されます。レスポンスには次の2つのタイプがあります。

* **full**：レスポンスにはすべてのフィーチャーフラグとセグメントが含まれます。
* **patch**：レスポンスにはタイムスタンプ以降に作成または更新された新しいフィーチャーフラグとセグメントのみが含まれます。

![](../tech-stack/assets/architecture-professional/002.png)

### フィーチャーフラグ/セグメントの変更のデータフロー

ユーザーがUIからフィーチャーフラグまたはセグメントを変更すると、APIサーバーはMongoDBにデータを保存するだけでなく、変更内容をKafkaにプッシュします。評価サーバーはこれらの変更を読み取り、Redisを更新し、変更に関連するフィーチャーフラグを評価し、関連するフィーチャーフラグまたは評価結果をクライアント/サーバーサイドのSDKにWebSocket接続を介して送信します。

![](../tech-stack/assets/architecture-professional/003.png)

### エンドユーザーデータのフロー

エンドユーザーデータはMongoDBに格納され、フィーチャーフラグとセグメントの対象として使用されます。

クライアントSDKがWebSocket接続を確立したり、別のユーザーに切り替えたり（identify APIを呼び出す）、クライアント/サーバーのSDKがトラックメッセージを送信したりすると、評価サーバーはエンドユーザー情報をKafkaに送信し、APIサーバーはそのデータを読み取り、MongoDBに更新/挿入します。

![](../tech-stack/assets/architecture-professional/004.png)

### フィーチャーフラグおよびメトリックトラックのデータフロー

フィーチャーフラグおよびメトリックトラックデータはClickHouseに格納され、A/B/nテスト（実験）およびレポートのために使用されます。

クライアント/サーバーのSDKがフィーチャーフラグおよびメトリックトラックメッセージを評価サーバーに送信すると、評価サーバーはトラックメッセージをKafkaに転送し、データ分析サーバーはKafkaからトラックメッセージを読み取り、ClickHouseに保存します。

![](../tech-stack/assets/architecture-professional/005.png)

## **すべてのデータはあなたのものです**

全体のアーキテクチャでは、データと通信はすべてシステム内に留まるため、プライバシーの側面も確保されています。データは第三者サービスに送信されません。すべてのデータの唯一の所有者はあなたですので、私たちは自信を持って、完全に[GDPR](https://gdpr-info.eu/)に準拠していると言えます。