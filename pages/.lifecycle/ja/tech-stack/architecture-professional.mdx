```markdown
import { コールアウト } from 'nextra/components'

＃アーキテクチャ - プロフェッショナル

<コールアウト タイプ="情報" >
このドキュメントはプロフェッショナルバージョンを想定しており、代わりに標準バージョンの[ アーキテクチャ](architecture.md)[ ](architecture.md)を参照してください。標準バージョンとプロフェッショナルバージョンの違いについては、[標準対プロフェッショナル](standard-vs.-professional.md)をご確認ください。
</コールアウト>

## **概要**

FeatBitは**スケーラブル**で**高速**なフィーチャーマネジメントプラットフォームです。FeatBitのミッションはすべてのチームに、ソフトウェアを提供、制御、実験、収益化する力を与えることです。

全体のアーキテクチャは次のとおりです：

！[](../tech-stack/assets/architecture-professional/001.png)

* **UI：**ユーザーに、フィーチャーフラグ、セグメント、実験などを管理および公開するためのビジュアルUIインターフェースを提供します。
* **APIサーバ：**UIおよびフラグトリガー、コード参照などの外部統合サービスのデータ管理機能を提供します。
* **評価サーバ：**スケーラブルで高性能なフラグのルール評価エンジンおよびデータ配布サーバを提供します。
* **データ分析サーバ：**データ分析エンジンを提供します。以下のサービスが提供されます
  *実験を計算し、ほぼリアルタイムで結果を返します。
  * UIのすべてのアナリティクスの洞察サービス、たとえば、フィーチャーフラグのレポーティングを提供します。
* **SDK：**主要な言語とフレームワークのためのSDKを提供し、サービスおよびアプリケーションからFeatBitへの迅速なアクセスを提供します。
* **Redis：**パフォーマンスを向上させるためのキャッシュレイヤー。
* **Kafka：**さまざまなサービス間の高スループット非同期データ通信を保証するメッセージキュー。全体のパフォーマンスを向上させるだけでなく、サービスを分離します。
* **MongoDB：**主なデータベース。すべてのフィーチャーフラグ、セグメント、実験、エンドユーザーデータがMongoDBに保存されます。
* **ClickHouse：**分析サービス用のデータベース。その中には、すべてのフィーチャーコールとメトリックコールのログが見つかります。

## スケーラブルで高性能

アーキテクチャを設計する際に、最も重要で唯一の懸念事項は、どのようにしてスケーラブルにし、可能な限り最高のパフォーマンスを得るかでした。そのために、私たちは慎重にテックスタックを選択し、すべてのサービスをコンテナ化しました。これにより、クラスターとして簡単にデプロイして**水平方向にスケーリング**できます。

データストレージとサービス間のデータフローに関しては、可能な限り最高のパフォーマンスを得るために、主なデータストアとしてMongoDB、システムキャッシュとしてRedis、メッセージキューとしてKafka、分析およびA/B/nテストデータのデータストアとしてClickHouseを導入しました。メッセージの送受信には**マルチプレキシング**および**パブ＆サブシステム**を使用し、平均的な応答時間はミリ秒単位です。

フィーチャーフラグの変更やその他の設定をSDKにプッシュすることはほぼリアルタイムです。UIからフラグが変更された場合に、SDKにデータをプッシュする時間は**100**ミリ秒未満です。長時間ポーリングの代わりに、WebSocketソリューションを採用しました。これにより、SDKに変更が発生した際に変更を積極的にプッシュできます。もちろん、これは無償ではありません。巨大な数の同時リクエストが発生した場合には膨大なメモリを消費する可能性があります。メモリモンスターにならないようにするために、データのシリアル化および非シリアル化プロセス中に余分なメモリを消費しないように慎重に選択しています。

## データフロー

システムが実行されている間、さまざまなサービス間でデータが流れます。主要なデータフローは4つあります。

### データ同期（フィーチャーフラグ/セグメント）データフロー

フィーチャーフラグ/セグメントデータはMongoDBに保存されており、FeatBitの主要な機能のための最も重要なデータストアです。

クライアントまたはサーバーSDKと評価サーバーの間で接続が確立された後、SDKはタイムスタンプを添付したデータ同期リクエストを評価サーバーに送信します。評価サーバ−はそのタイムスタンプをチェックし、Redisから該当するフィーチャーフラグとセグメントを取得し、最終的な評価プロセス（クライアントSDKのみ）の後、結果をSDKに送信します。応答には次の2種類があります：

* **完全**:応答にはすべてのフィーチャーフラグとセグメントが含まれます
* **パッチ**:応答にはタイムスタンプ以降に作成または更新された新しいフィーチャーフラグとセグメントのみが含まれます

！[](../tech-stack/assets/architecture-professional/002.png)
  
### フィーチャーフラグ/セグメント変更データフロー

ユーザーがUIからフィーチャーフラグまたはセグメントを変更すると、MongoDBにデータを保存するだけでなく、APIサーバーは変更をKafkaにプッシュし、評価サーバーはそれらの変更を読み取り、Redisを更新し、変更に関連するフィーチャーフラグを評価し、関連するフィーチャーフラグまたは評価結果をクライアント/サーバーサイドのSDKにWebSocket接続を介して送信します。

！[](../tech-stack/assets/architecture-professional/003.png)

### エンドユーザーデータフロー

エンドユーザーデータはMongoDBに保存され、フィーチャーフラグおよびセグメントのターゲティングのために使用されます。

クライアントSDKがWebSocket接続を確立するか、他のユーザーに切り替える（識別APIを呼び出す）か、クライアント/サーバーSDKがトラックメッセージを送信すると、評価サーバ−はエンドユーザー情報をKafkaに送信し、その後APIサーバーがそのデータを読み取り、MongoDBに更新/挿入します。

！[](../tech-stack/assets/architecture-professional/004.png)

### フィーチャーフラグとメトリックトラックデータフロー

フィーチャーフラグおよびメトリックトラックデータはClickHouseに保存され、A/B/nテスト（実験）およびレポーティングに使用されます。

クライアント/サーバーSDKがフィーチャーフラグおよびメトリックトラックメッセージを評価サーバ−に送信すると、後者はトラックメッセージをKafkaに転送し、データ分析サーバ−はKafkaからトラックメッセージを読み取り、それらをClickHouseに保存します。

！[](../tech-stack/assets/architecture-professional/005.png)

## **データはすべてあなたのものです**

全体のアーキテクチャは、すべてのデータと通信がシステム内にとどまるため、プライバシーの側面も確保されています。データは第三者サービスに送信されません。すべてのデータの唯一の所有者はあなたです。これにより、私たちが完全に[GDPR](https://gdpr-info.eu/)に準拠していることを自信を持って主張できます。
```