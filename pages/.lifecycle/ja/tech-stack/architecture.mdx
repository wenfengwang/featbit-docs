```
import { Callout } from 'nextra/components'

# アーキテクチャ

<Callout type="info">
  このドキュメントは標準版を対象としています。プロフェッショナル版については[Architechture - Professional](architecture-professional.md)を参照してください。標準版とプロフェッショナル版の違いについては、[Standard VS. Professional](standard-vs.-professional.md)をご確認ください。
</Callout>

## **概要**

FeatBitは**拡張可能**で**高速**なフィーチャーマネジメントプラットフォームです。FeatBitのミッションは、すべてのチームにソフトウェアを提供し、制御し、実験し、収益化する能力を与えることです。

全体的なアーキテクチャは以下のようになっています。

![](../tech-stack/assets/architecture/001.webp)

* **UI:** ユーザーに対して、フィーチャーフラグ、セグメント、実験などの管理と公開のための視覚的なUIインターフェースを提供します。
* **APIサーバ:** UIおよび外部連携サービス（フラグトリガーやコード参照など）のデータ管理機能を提供します。
* **評価サーバ:** 拡張可能で高性能なフラグルール評価エンジンおよびデータ配信サーバを提供します。
* **データアナリティクスサーバ:** データアナリティクスエンジンを提供します。以下のサービスを保証します
  * 実験を計算し、ほぼリアルタイムでその結果を返します。
  * UIのすべてのアナリティクスに対する洞察サービス（たとえば、フィーチャーフラグレポーティングなど）を提供します。
* **SDK:** すべての主要な言語とフレームワーク用のSDKを提供し、サービスやアプリケーションからFeatBitに素早くアクセスできるようにします。
* **Redis:** 2つの役割があります
  * パフォーマンスを向上させるためのキャッシュレイヤー。
  * 異なるサービス間での高スループット非同期データ通信を保証するメッセージキュー。
* **MongoDB:** メインのデータベースです。すべてのフィーチャーフラグ、セグメント、実験、エンドユーザー、およびアナリティクスデータがMongoDBに保存されています。

## 拡張可能で高性能

アーキテクチャの設計時に、最も重要で唯一の懸念事項は、どのようにして拡張可能にし、最高のパフォーマンスを得るかでした。そのために、私たちは注意を払い、私たちのテックスタックを厳選し、すべてのサービスをコンテナ化しました。これにより、クラスターとして簡単に展開し、**水平方向に拡張**することができます。

データストレージとサービス間のデータフローについては、最高のパフォーマンスを得るために、主要データストアとしてMongoDBを導入し、システムキャッシュおよびメッセージキューとしてRedisを使用しています。メッセージの送受信には**マルチプレクシング**および**Pub & Subシステム**を使用しており、平均反応時間はミリ秒単位です。

フィーチャーフラグの変更やその他の設定をSDKにプッシュすると、ほぼリアルタイムで行われます。UIからフラグが変更されたとき、データをSDKにプッシュする時間が**100**ミリ秒未満かかります。ロングポーリングの代わりに、WebSocketソリューションが採用されており、変更が発生した際にSDKに変更を積極的にプッシュできます。もちろん、これにはコストがかかります。大量の同時リクエストが発生すると、膨大なメモリを消費する可能性があります。メモリモンスターにならないようにするために、データのシリアライズおよびデシリアライズ方法を慎重に選択し、シリアライズおよびデシリアライズの過程で余分なメモリを消費しないようにしています。

## データフロー

システムが稼働しているとき、データは異なるサービス間を流れます。主要なデータフローは4つあります。

### データ同期（フィーチャーフラグ/セグメント）のデータフロー

フィーチャーフラグ/セグメントデータはMongoDBに保存されており、FeatBitの主要機能のために使用されています。

クライアントまたはサーバSDKと評価サーバの間に接続が確立された後、SDKは最新の変更のタイムスタンプを添付したデータ同期リクエストを評価サーバに送信します。評価サーバはそのタイムスタンプを確認し、Redisから適格なフィーチャーフラグとセグメントを取得し、その後の評価プロセス（クライアントSDKのみ）の後、結果をSDKに送信します。応答には次の2つのタイプがあります。

* **full**: 応答にはすべてのフィーチャーフラグとセグメントが含まれています。
* **patch**: 応答には、タイムスタンプ以降に作成または更新された新しいフィーチャーフラグとセグメントのみが含まれています。

![](../tech-stack/assets/architecture/002.png)

### フィーチャーフラグ/セグメント変更のデータフロー

ユーザーがUIからフィーチャーフラグまたはセグメントを変更すると、MongoDBにデータを保存するだけでなく、APIサーバは変更をKafkaにプッシュし、評価サーバがそれらの変更を読み取り、Redisを更新し、変更に関連するフィーチャーフラグを評価し、関連するフィーチャーフラグまたは評価結果をクライアント/サーバ側SDKにWebSocket接続を介して送信します。

![](../tech-stack/assets/architecture/003.png)

### エンドユーザーデータのフロー

エンドユーザーデータはMongoDBに保存され、フィーチャーフラグおよびセグメントのターゲティングに使用されます。

クライアントSDKがWebSocket接続を確立したり、別のユーザに切り替えたり（identify APIを呼び出すことで）、クライアント/サーバSDKがトラックメッセージを送信したりすると、評価サーバがエンドユーザー情報をKafkaに送信し、APIサーバがそのデータを読み取り、MongoDBに更新/挿入します。

![](../tech-stack/assets/architecture/004.png)

### フィーチャーフラグおよびメトリックトラックのデータフロー

フィーチャーフラグおよびメトリックトラックデータはClickHouseに保存され、A/B/nテスト（実験）およびレポーティングに使用されます。

クライアント/サーバSDKがフィーチャーフラグおよびメトリックトラックメッセージを評価サーバに送信すると、後者がトラックメッセージをKafkaに転送し、データアナリティクスサーバがKafkaからトラックメッセージを読み取り、それをClickHouseに保存します。

![](../tech-stack/assets/architecture/005.png)

## **あなたのデータはすべてあなた自身のものです**

全体的なアーキテクチャは、すべてのデータと通信がシステム内で完結しているため、プライバシーの側面を確保します。いかなるデータも第三者に送信しません。あなたのデータはすべてあなた自身のものであり、私たちが完全に[GDPR](https://gdpr-info.eu/)に準拠していると自信を持って述べることができます。
```