import { Callout } from 'nextra/components'

# アーキテクチャ


<Callout type="info" >
  このドキュメントは標準版向けです。プロフェッショナル版については、[アーキテクチャ - プロフェッショナル](architecture-professional.md)を参照してください。標準版とプロフェッショナル版の違いについては、[標準vsプロフェッショナル](standard-vs.-professional.md)をご確認ください。
</Callout>

## **概要**

FeatBitは、**スケーラブル**で**高速**なフィーチャーマネジメントプラットフォームです。FeatBitのミッションは、すべてのチームにソフトウェアの配信、制御、実験、収益化ができる力を与えることです。

全体のアーキテクチャは次のようになっています：

![](../tech-stack/assets/architecture/001.webp)

* **UI：** ユーザーがフィーチャーフラグ、セグメント、実験などを管理および公開するための視覚的なUIインターフェースを提供します。
* **APIサーバー：** UIと外部連携サービス（フラグトリガー、コードリファレンスなど）のためのデータ管理機能を提供します。
* **評価サーバー：** スケーラブルかつ高パフォーマンスなフラグルール評価エンジンとデータ配布サーバーを提供します。
* **データ分析サーバー：** データ分析エンジンを提供します。以下のサービスを保証します
  * 実験を計算し、リアルタイムで結果を返します。
  * UIのすべての分析の洞察サービス、たとえばフィーチャーフラグのレポートなどを提供します。
* **SDK：** 主要な言語とフレームワークに対応したSDKを提供しており、お客様のサービスやアプリケーションから簡単にFeatBitにアクセスできます。
* **Redis：** 2つの役割があります
  * パフォーマンス向上のためのキャッシュレイヤー。
  * 異なるサービス間の高スループット非同期データ通信を保証するメッセージキュー。
* **MongoDB：** メインデータベースです。すべてのフィーチャーフラグ、セグメント、実験、エンドユーザー、分析データはMongoDBに保存されます。

## スケーラブルで高パフォーマンス

アーキテクチャを設計する際、最も重要で唯一の関心事は、スケーラブルにすることと最高のパフォーマンスを得ることです。そのために、私たちは注意深くテックスタックを選び、すべてのサービスをコンテナ化しました。これにより、クラスターとして簡単にデプロイし、**水平方向にスケール**することができます。

データストレージとサービス間のデータフローに関しては、最高のパフォーマンスを得るために、メインのデータストアとしてMongoDBを導入し、システムキャッシュおよびメッセージキューとしてRedisを使用しています。メッセージの送受信には**マルチプレクシング**と**パブリッシュ＆サブシステム**を使用しており、平均反応時間はミリ秒単位です。

フィーチャーフラグの変更や他の設定をSDKにプッシュすることはリアルタイムに近いです。UIからフラグが変更された場合、データをSDKにプッシュするのに**100**ミリ秒未満かかります。ロングポーリングではなく、WebSocketソリューションを採用しており、変更が発生するとSDKに変更を積極的にプッシュできます。もちろん、これは無料ではありませんが、大量の同時リクエストが発生すると、膨大なメモリを消費する可能性があります。メモリの無駄を避けるため、データのシリアライズとデシリアライズのプロセス中に余分なメモリを消費しないように、慎重にデータを選択しました。

## データフロー

システムが稼働しているとき、さまざまなサービス間でデータがフローします。主要なデータフローは4つあります：

### データ同期（フィーチャーフラグ/セグメント）のデータフロー

フィーチャーフラグ/セグメントデータはMongoDBに格納され、FeatBitの主要な機能のためにサーブされます。

クライアントまたはサーバーSDKと評価サーバーの間に接続が確立された後、SDKは最新の変更のタイムスタンプが付いたデータ同期リクエストを評価サーバーに送信します。評価サーバーはそのタイムスタンプをチェックし、Redisから該当するフィーチャーフラグとセグメントを取得します。評価プロセス（クライアントSDKの場合のみ）の後、結果はSDKに送信されます。レスポンスには次の2つのタイプがあります：

* **フル**：レスポンスにはすべてのフィーチャーフラグとセグメントが含まれます。
* **パッチ**：レスポンスにはタイムスタンプ以降に作成または更新された新しいフィーチャーフラグとセグメントのみが含まれます。

![](../tech-stack/assets/architecture/002.png)

### フィーチャーフラグ/セグメントの変更データフロー

ユーザーがUIからフィーチャーフラグまたはセグメントを変更すると、MongoDBにデータを格納するだけでなく、APIサーバーは変更内容をKafkaにプッシュします。評価サーバーはこれらの変更を読み取り、Redisを更新し、変更に関連するフィーチャーフラグを評価し、関連するフィーチャーフラグまたは評価結果をクライアント/サーバーサイドのSDKにWebSocket接続を介して送信します。

![](../tech-stack/assets/architecture/003.png)

### エンドユーザーデータフロー

エンドユーザーデータはMongoDBに格納され、フィーチャーフラグやセグメントのターゲティングに使用されます。

クライアントSDKがWebSocket接続を確立したり、他のユーザーに切り替えたり（identify APIを呼び出す）、クライアント/サーバーSDKがトラックメッセージを送信したりすると、評価サーバーはエンドユーザー情報をKafkaに送信し、APIサーバーはそのデータを読み取り、MongoDBに更新/挿入します。

![](../tech-stack/assets/architecture/004.png)

### フィーチャーフラグとメトリックトラックのデータフロー

フィーチャーフラグとメトリックトラックデータはClickHouseに格納され、A/B/nテスト（実験）とレポートに使用されます。

クライアント/サーバーSDKがフィーチャーフラグとメトリックトラックメッセージを評価サーバーに送信すると、後者はトラックメッセージをKafkaに転送し、データ分析サーバーはKafkaからトラックメッセージを読み取り、ClickHouseに保存します。

![](../tech-stack/assets/architecture/005.png)

## **すべてのデータはあなたのものです**

全体のアーキテクチャは、データと通信がシステム内に留まるため、プライバシーの側面も確保されています。データは第三者のサービスに送信されません。あなたはすべてのデータの唯一の所有者です。また、私たちは自信を持って完全に[GDPR](https://gdpr-info.eu/)に準拠していると言えます。