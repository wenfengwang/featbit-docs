import { Callout } from 'nextra/components'

# アーキテクチャ


<Callout type="info" >
  このドキュメントは標準バージョン向けです。プロフェッショナルバージョンについては[アーキテクチャ - プロフェッショナル](architecture-professional.md)を参照してください。標準版とプロフェッショナル版の違いについては、[標準版 VS プロフェッショナル版](standard-vs.-professional.md)をご覧ください。
</Callout>

## **概要**

FeatBitは、**スケーラブル**かつ**高速**なフィーチャーマネジメントプラットフォームです。FeatBitのミッションは、すべてのチームがソフトウェアを提供、制御、実験し、収益化することを可能にすることです。

全体的なアーキテクチャは以下の通りです：

![](../tech-stack/assets/architecture/001.webp)

* **UI :** ユーザーに機能フラグ、セグメント、実験などを管理・公開するための視覚的なUIインターフェースを提供します。
* **APIサーバー :** UIおよび外部統合サービス（フラグトリガー、コード参照など）のデータ管理機能を提供します。
* **評価サーバー :** スケーラブルで高性能なフラグルール評価エンジンとデータ配信サーバーを提供します。
* **データアナリティクスサーバー :** データ分析エンジンを提供します。以下のサービスを保証します：
  * 実験を計算し、その結果をほぼリアルタイムで返します。
  * UIのすべての分析についてのインサイトサービスを提供します。例えば、フィーチャーフラグレポートなどです。
* **SDK:** すべての主要な言語とフレームワーク向けのSDKを提供し、サービスやアプリケーションからFeatBitに迅速にアクセスできるようにします。
* **Redis :** 二つの役割を果たします：
  * パフォーマンスを向上させるキャッシュレイヤー。
  * 異なるサービス間で高スループットの非同期データ通信を保証するメッセージキュー。
* **MongoDB :** 主データベース。すべてのフィーチャーフラグ、セグメント、実験、エンドユーザー、分析データはMongoDBに格納されます。

## スケーラブルかつ高性能

アーキテクチャの設計において、最も重要かつ唯一の関心事は、どのようにしてスケーラブルにし、可能な限り最高のパフォーマンスを実現するかでした。そのために、技術スタックを慎重に選択し、すべてのサービスをコンテナ化しました。これにより、クラスタとしてのデプロイが容易になり、**水平スケーリング**が非常にシンプルになります。

データストレージとサービス間のデータフローに関しては、最高のパフォーマンスを実現するため、MongoDBを主データストアとして、Redisをシステムキャッシュおよびメッセージキューとして導入しました。サービス間でメッセージを送受信するために**マルチプレクシング**と**Pub/Subシステム**を使用しており、平均反応時間はミリ秒単位です。

フィーチャーフラグの変更やその他の設定をSDKにプッシュするのはほぼリアルタイムです。UIからフラグが変更された場合、SDKへのデータプッシュには**100ミリ秒未満**かかります。長時間のポーリングの代わりに、WebSocketソリューションが採用されています。これにより、変更が発生した際にSDKに対して積極的にプッシュが可能です。もちろん、これはメモリを大量に消費する可能性があるため、メモリモンスターにならないように、シリアライズとデシリアライズのプロセス中に余分なメモリを消費しない方法を慎重に選択しました。

## データフロー

システムが稼働している際、異なるサービス間でデータが流れます。主なデータフローは4つあります：

### データ同期（フィーチャーフラグ／セグメント）データフロー

フィーチャーフラグ／セグメントデータはMongoDBに保存され、FeatBitのすべての主要機能にとって最も重要なデータストアとなります。

クライアントまたはサーバーSDKと評価サーバー間の接続が確立された後、SDKは最新の変更のタイムスタンプを添付したデータ同期リクエストを評価サーバーに送信します。評価サーバーはそのタイムスタンプを確認し、Redisから適格なフィーチャーフラグとセグメントを取得した後、最終的な評価プロセス（クライアントSDKのみ）を経て、結果をSDKに返送します。応答には以下の2種類があります：

* **full**: 応答にはすべてのフィーチャーフラグとセグメントが含まれます。
* **patch**: 応答には、タイムスタンプ以降に作成または更新された新しいフィーチャーフラグとセグメントのみが含まれます。

![](../tech-stack/assets/architecture/002.png)

### フィーチャーフラグ／セグメント変更データフロー

ユーザーがUIからフィーチャーフラグまたはセグメントを変更すると、MongoDBにデータを保存するだけでなく、APIサーバーも変更をKafkaにプッシュします。評価サーバーはこれらの変更を読み取り、Redisを更新し、変更に関連するフィーチャーフラグを評価し、関連するフィーチャーフラグまたは評価結果をWebSocket接続を介してクライアント／サーバーSDKに送信します。

![](../tech-stack/assets/architecture/003.png)

### エンドユーザーデータフロー

エンドユーザーデータはMongoDBに保存され、フィーチャーフラグとセグメントのターゲティングに使用されます。

クライアントSDKがWebSocket接続を確立するか、別のユーザーに切り替えるか（identify APIを呼び出す）、またはクライアント／サーバーSDKがトラックメッセージを送信すると、評価サーバーはエンドユーザー情報をKafkaに送信します。その後、APIサーバーがそのデータを読み取り、MongoDBに更新／挿入します。

![](../tech-stack/assets/architecture/004.png)

### フィーチャーフラグとメトリックトラックデータフロー

フィーチャーフラグとメトリックトラックデータはClickHouseに保存され、A/B/nテスト（実験）とレポーティングに使用されます。

クライアント／サーバーSDKがフィーチャーフラグとメトリックトラックメッセージを評価サーバーに送信すると、評価サーバーはトラックメッセージをKafkaに転送し、データアナリティクスサーバーがKafkaからトラックメッセージを読み取り、ClickHouseに保存します。

![](../tech-stack/assets/architecture/005.png)

## **あなたがすべてのデータの唯一の所有者です**

全体的なアーキテクチャは、すべてのデータと通信がシステム内に留まるため、プライバシーの側面も確保されています。サードパーティのサービスにデータを送信することはありません。お客様はすべてのデータの唯一の所有者であり、これにより我々は[GDPR](https://gdpr-info.eu/)に完全に準拠していると自信を持って言えます。
